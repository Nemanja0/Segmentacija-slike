/*****************************************************************************
 * Optimised_C.c
 *****************************************************************************/

#include <sys/platform.h>
#include "adi_initialize.h"
#include "Optimised_C.h"
#include <stdio.h>
#include <def21489.h>
#include <sru21489.h>
#include <SYSREG.h>
#include <stdlib.h>
#include <time.h>
#include "bmp_operations.h"
#include "stack.h"
//int index_int;

/*#pragma section("seg_hp2")
static byte extra_heap[250000];

#pragma section("seg_hp1")
static int extra_heap_int[100];*/

const char* image = "slike/slika4.bmp";
const char* grayscale_image = "obradjene_slike/Grayscale.bmp";
const char* gaussian_blur_image = "obradjene_slike/Gaussian_blur.bmp";
const char* laplacian_picture_image = "obradjene_slike/Laplacian_picture.bmp";
const char* painted_picture_image = "obradjene_slike/Painted_picture.bmp";

void InitSRU(void)
{
	//** LED01**//
	SRU(HIGH,DPI_PBEN06_I);
	SRU(FLAG4_O,DPI_PB06_I);
	//** LED02**//
	SRU(HIGH,DPI_PBEN13_I);
	SRU(FLAG5_O,DPI_PB13_I);
	//** LED03**//
	SRU(HIGH,DPI_PBEN14_I);
	SRU(FLAG6_O,DPI_PB14_I);
	//** LED04**//
	SRU(HIGH,DAI_PBEN03_I);
	SRU(HIGH,DAI_PB03_I);
	//** LED05**//
	SRU(HIGH,DAI_PBEN04_I);
	SRU(HIGH,DAI_PB04_I);
	//** LED06**//
	SRU(HIGH,DAI_PBEN15_I);
	SRU(HIGH,DAI_PB15_I);
	//** LED07**//
	SRU(HIGH,DAI_PBEN16_I);
	SRU(HIGH,DAI_PB16_I);
	//** LED08**//
	SRU(HIGH,DAI_PBEN17_I);
	SRU(HIGH,DAI_PB17_I);
	//Setting flag pins as outputs
	sysreg_bit_set(sysreg_FLAGS, (FLG4O|FLG5O|FLG6O) );
	//Setting HIGH to flag pins
	sysreg_bit_set(sysreg_FLAGS, (FLG4|FLG5|FLG6) );
}

void returnOffsets(int32 w, int offset, int* offsets){
    offsets[0] = offset - 3*w - 3;
    offsets[1] = offset - 3*w;
    offsets[2] = offset - 3*w + 3;
    offsets[3] = offset - 3;
    offsets[4] = offset;
    offsets[5] = offset + 3;
    offsets[6] = offset + 3*w - 3;
    offsets[7] = offset + 3*w;
    offsets[8] = offset + 3*w + 3;
}

void dfs(byte* pixels, int32 w, int32 h, int offset, unsigned char* paint){
    int* offsets = (int*)heap_malloc(1, 10*sizeof(int));
    int empty, off;
    push(offset);
    //isEmpty(&empty);
    while(!isEmpty()){
        off = pop();
        if (off < 3*w || off%(3*w) == 0 || (off+3)%(3*w) == 0 || off > 3*w*(h-1))
            continue;
        returnOffsets(w, off, offsets);
        if (!(pixels[offsets[4]] == 0x00 || pixels[offsets[4]+1] == 0x00 || pixels[offsets[4]+2] == 0x00))
            continue;
        pixels[offsets[4]] = paint[0];
        pixels[offsets[4]+1] = paint[1];
        pixels[offsets[4]+2] = paint[2];
        push(offsets[1]);
        push(offsets[3]);
        push(offsets[5]);
        push(offsets[7]);
        //isEmpty(&empty);
    }
    printf("Off2: %d\n", off);
    heap_free(1, offsets);
}

void findBlackSpots(byte* pixels, int32 w, int32 h, int* offset){
    int* offsets = (int*)heap_malloc(1, 10*sizeof(int));
    *offset = -1;
    for(int i = 0; i < 3*w*h; i+=3){
        returnOffsets(w, i, offsets);
        if(pixels[offsets[4]] == 0x00 && pixels[offsets[4]+1] == 0x00 && pixels[offsets[4]+2] == 0x00){
            *offset = i;
            break;
        }
    }
    heap_free(1, offsets);
}

void randomColor(unsigned char* paint){
    for(int i = 0; i < 3; i++)
        paint[i] = rand()%254+1;
}

void paintWhiteSpots(byte* pixels, int32 w, int32 h){
    for(int i = 0; i < 3*w*h; i+=3){
        if(pixels[i] == 0xff && pixels[i+1] == 0xff && pixels[i+2] == 0xff){
            pixels[i] = 0x00;
            pixels[i+1] = 0x00;
            pixels[i+2] = 0x00;
        }
    }
}
/** 
 * If you want to use command program arguments, then place them in the following string. 
 */
char __argv_string[] = "";

int main(int argc, char *argv[])
{
	/**
	 * Initialize managed drivers and/or services that have been added to 
	 * the project.
	 * @return zero on success 
	 */
	adi_initComponents();
	InitSRU();
	//turn off LEDs
	sysreg_bit_clr(sysreg_FLAGS, FLG4);
	sysreg_bit_clr(sysreg_FLAGS, FLG5);
	sysreg_bit_clr(sysreg_FLAGS, FLG6);
	SRU(LOW,DAI_PB03_I);
	SRU(LOW,DAI_PB04_I);
	SRU(LOW,DAI_PB15_I);
	SRU(LOW,DAI_PB16_I);
	SRU(LOW,DAI_PB17_I);

	 /* Install extra_heap[] as a heap */
	/*int uid = 999, uid_int = 998;
	index = heap_install(extra_heap, sizeof(extra_heap), uid);
	if (index < 0)
	{
		 printf("installation failed\n");
		 return 1;
	}
	
	index_int = heap_install(extra_heap_int, sizeof(extra_heap), uid_int);
	if (index_int < 0)
	{
		 printf("installation failed\n");
		 return 1;
	}*/

	int32 w, h, bpp;
	byte* pixels, *pixels_copy,* paint = (byte*)heap_malloc(1, 4*sizeof(byte));
	int gray, blur, laplacian, offset;
	int* offsets = (int*)heap_malloc(1, 10*sizeof(int));
	srand(time(0));

	ReadImage(image, &pixels, &w, &h, &bpp);
	sysreg_bit_set(sysreg_FLAGS, FLG4);

	/*****************************Grayscale******************************/

	for(int i = 0; i < 3*w*h; i+=3){
		gray = 0.299*pixels[i] + 0.587*pixels[i+1] + 0.114*pixels[i+2];
		pixels[i] = gray;
		pixels[i+1] = gray;
		pixels[i+2] = gray;
	}

	//WriteImage(grayscale_image, pixels, w, h, bpp);
	printf("Grayscale finished!\n");
	sysreg_bit_set(sysreg_FLAGS, FLG5);

	/********************************************************************/
	/*************************Gaussian blur******************************/

	copyImage(&pixels_copy, pixels, w, h, bpp);

	for(int i = 3*w; i < 3*w*(h-1); i+=3){
		if(i%(3*w) == 0 || (i+3)%(3*w) == 0){
			continue;
		}
		returnOffsets(w, i, offsets);
		blur = 0.25*pixels_copy[offsets[4]] + 0.0625*(pixels_copy[offsets[0]] + pixels_copy[offsets[2]] + pixels_copy[offsets[6]] + pixels_copy[offsets[8]]) + 0.125*(pixels_copy[offsets[1]] + pixels_copy[offsets[3]] + pixels_copy[offsets[5]] + pixels_copy[offsets[7]]);
		pixels[offsets[4]] = blur;
		pixels[offsets[4]+1] = blur;
		pixels[offsets[4]+2] = blur;
	}

	//WriteImage(gaussian_blur_image, pixels, w, h, bpp);
	heap_free(1, pixels_copy);
	printf("Blur finished!\n");
	sysreg_bit_set(sysreg_FLAGS, FLG6);

	/********************************************************************/
	/***************************Laplacian********************************/

	copyImage(&pixels_copy, pixels, w, h, bpp);

	for(int i = 3*w; i < 3*w*(h-1); i+=3){
		if(i%(3*w) == 0 || (i+3)%(3*w) == 0){
			continue;
		}
		returnOffsets(w, i, offsets);
		laplacian = 8*pixels_copy[offsets[4]] - (pixels_copy[offsets[0]] + pixels_copy[offsets[2]] + pixels_copy[offsets[6]] + pixels_copy[offsets[8]] + pixels_copy[offsets[1]] + pixels_copy[offsets[3]] + pixels_copy[offsets[5]] + pixels_copy[offsets[7]]);
		pixels[offsets[4]] = laplacian;
		pixels[offsets[4]+1] = laplacian;
		pixels[offsets[4]+2] = laplacian;
		/*if(pixels[i] > 0 && pixels[i+1] > 0 && pixels[i+2] > 0){
			pixels[i] = 0xff;
			pixels[i+1] = 0xff;
			pixels[i+2] = 0xff;
		}
		else{
			pixels[i] = 0x00;
			pixels[i+1] = 0x00;
			pixels[i+2] = 0x00;
		}*/
	}

	//WriteImage(laplacian_picture_image, pixels, w, h, bpp);
	heap_free(1, pixels_copy);
	printf("Laplacian finished!\n");
	SRU(HIGH,DAI_PB03_I);


	/********************************************************************/
	/******************************Painting******************************/

	while(1){
		findBlackSpots(pixels, w, h, &offset);
		if(offset == -1){
			//paintWhiteSpots(pixels, w, h);
			break;
		}
		randomColor(paint);
		dfs(pixels, w, h, offset, paint);
	}
	WriteImage(painted_picture_image, pixels, w, h, bpp);
	printf("Painting finished!\n");
	SRU(HIGH,DAI_PB04_I);


	/********************************************************************/

	heap_free(1, paint);
	heap_free(1, offsets);
	return 0;
}

