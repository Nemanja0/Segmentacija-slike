/*****************************************************************************
 * Optimised_C.c
 *****************************************************************************/

#include <sys/platform.h>
#include "adi_initialize.h"
#include "Optimised_C.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "bmp_operations.h"
#include "stack.h"


const char* image = "slike/slika.bmp";
const char* grayscale_image = "obradjene_slike/Grayscale.bmp";
const char* gaussian_blur_image = "obradjene_slike/Gaussian_blur.bmp";
const char* laplacian_picture_image = "obradjene_slike/Laplacian_picture.bmp";
const char* painted_picture_image = "obradjene_slike/Painted_picture.bmp";


void returnOffsets(int32 w, int offset, int* offsets){
    offsets[0] = offset - 3*w - 3;
    offsets[1] = offset - 3*w;
    offsets[2] = offset - 3*w + 3;
    offsets[3] = offset - 3;
    offsets[4] = offset;
    offsets[5] = offset + 3;
    offsets[6] = offset + 3*w - 3;
    offsets[7] = offset + 3*w;
    offsets[8] = offset + 3*w + 3;
}

void dfs(byte* pixels, int32 w, int32 h, int offset, unsigned char* paint){
    int* offsets = (int*)malloc(10*sizeof(int));
    int empty, off;
    push(offset);
    isEmpty(&empty);
    while(!empty){
        pop(&off);
        if (off < 3*w || off%(3*w) == 0 || (off+3)%(3*w) == 0 || off > 3*w*(h-1))
            continue;
        returnOffsets(w, off, offsets);
        if (!(pixels[offsets[4]] == 0x00 || pixels[offsets[4]+1] == 0x00 || pixels[offsets[4]+2] == 0x00))
            continue;
        pixels[offsets[4]] = paint[0];
        pixels[offsets[4]+1] = paint[1];
        pixels[offsets[4]+2] = paint[2];
        push(offsets[1]);
        push(offsets[3]);
        push(offsets[5]);
        push(offsets[7]);
        isEmpty(&empty);
    }
    free(offsets);
}

void findBlackSpots(byte* pixels, int32 w, int32 h, int* offset){
    int* offsets = (int*)malloc(10*sizeof(int));
    *offset = -1;
    for(int i = 0; i < 3*w*h; i+=3){
        returnOffsets(w, i, offsets);
        if(pixels[offsets[4]] == 0x00 && pixels[offsets[4]+1] == 0x00 && pixels[offsets[4]+2] == 0x00){
            *offset = i;
            break;
        }
    }
    free(offsets);
}

void randomColor(unsigned char* paint){
    for(int i = 0; i < 3; i++)
        paint[i] = rand()%254+1;
}

void paintWhiteSpots(byte* pixels, int32 w, int32 h){
    for(int i = 0; i < 3*w*h; i+=3){
        if(pixels[i] == 0xff && pixels[i+1] == 0xff && pixels[i+2] == 0xff){
            pixels[i] = 0x00;
            pixels[i+1] = 0x00;
            pixels[i+2] = 0x00;
        }
    }
}
/** 
 * If you want to use command program arguments, then place them in the following string. 
 */
char __argv_string[] = "";

int main(int argc, char *argv[])
{
	/**
	 * Initialize managed drivers and/or services that have been added to 
	 * the project.
	 * @return zero on success 
	 */
	adi_initComponents();
	 /* Install extra_heap[] as a heap */
	int uid = 999;
	index = heap_install(extra_heap, sizeof(extra_heap), uid);
	if (index < 0)
	{
		 printf("installation failed\n");
		 return 1;
	}
	
	int32 w, h, bpp;
	byte* pixels, *pixels_copy;
	int gray, blur, laplacian, offset;
	int* offsets = (int*)malloc(10*sizeof(int));
	unsigned char* paint = (unsigned char*)malloc(4*sizeof(unsigned char));
	srand(time(0));

	ReadImage(image, &pixels, &w, &h, &bpp);

	//printf("%s\n", pixels);

	/*****************************Grayscale******************************/

	for(int i = 0; i < 3*w*h; i+=3){
		gray = 0.299*pixels[i] + 0.587*pixels[i+1] + 0.114*pixels[i+2];
		pixels[i] = gray;
		pixels[i+1] = gray;
		pixels[i+2] = gray;
	}
	printf("Gotova for petlja.\n");
	WriteImage(grayscale_image, pixels, w, h, bpp);
	printf("Grayscale finished!\n");

	/********************************************************************/
	/*************************Gaussian blur******************************/

	ReadImage(grayscale_image, &pixels_copy, &w, &h, &bpp);

	for(int i = 3*w; i < 3*w*(h-1); i+=3){
		if(i%(3*w) == 0 || (i+3)%(3*w) == 0){
			continue;
		}
		returnOffsets(w, i, offsets);
		blur = 0.25*pixels_copy[offsets[4]] + 0.0625*(pixels_copy[offsets[0]] + pixels_copy[offsets[2]] + pixels_copy[offsets[6]] + pixels_copy[offsets[8]]) + 0.125*(pixels_copy[offsets[1]] + pixels_copy[offsets[3]] + pixels_copy[offsets[5]] + pixels_copy[offsets[7]]);
		pixels[offsets[4]] = blur;
		pixels[offsets[4]+1] = blur;
		pixels[offsets[4]+2] = blur;
	}

	WriteImage(gaussian_blur_image, pixels, w, h, bpp);
	heap_free(index, pixels_copy);
	printf("Blur finished!\n");

	/********************************************************************/
	/***************************Laplacian********************************/

	ReadImage(gaussian_blur_image, &pixels_copy, &w, &h, &bpp);

	for(int i = 3*w; i < 3*w*(h-1); i+=3){
		if(i%(3*w) == 0 || (i+3)%(3*w) == 0){
			continue;
		}
		returnOffsets(w, i, offsets);
		laplacian = 8*pixels_copy[offsets[4]] - (pixels_copy[offsets[0]] + pixels_copy[offsets[2]] + pixels_copy[offsets[6]] + pixels_copy[offsets[8]] + pixels_copy[offsets[1]] + pixels_copy[offsets[3]] + pixels_copy[offsets[5]] + pixels_copy[offsets[7]]);
		pixels[offsets[4]] = laplacian;
		pixels[offsets[4]+1] = laplacian;
		pixels[offsets[4]+2] = laplacian;
	}

	WriteImage(laplacian_picture_image, pixels, w, h, bpp);
	heap_free(index, pixels_copy);
	printf("Laplacian finished!\n");

	/********************************************************************/
	/******************************Painting******************************/

	while(1){
		findBlackSpots(pixels, w, h, &offset);
		if(offset == -1){
			//paintWhiteSpots(pixels, w, h);
			break;
		}
		randomColor(paint);
		dfs(pixels, w, h, offset, paint);
	}

	WriteImage(painted_picture_image, pixels, w, h, bpp);
	printf("Painting finished!\n");

	/********************************************************************/

	heap_free(index, paint);
	heap_free(index, offsets);
	return 0;
}

